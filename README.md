# GPSPostQuantum

This repository implements the [Galbraith--Petit--Silva](https://eprint.iacr.org/2016/1154.pdf) quantum-resistant cryptosystem, introduced in ASIACRYPT 2017. It uses as a dependency the number-theory library LiDIA, in [a fork of which](https://github.com/benediamond/LiDIA/tree/f_q_support) I have added extended support for point-counting-related operations on curves over prime-power-order fields. As far as I know, it is the first implementation of this theoretically compelling post-quantum cryptosystem.

## Technical Notes

### Overview

My approach diverges in few respects from the original paper of GPS.

Most importantly, I never factor division polynomials during key- or signature-generation, either when conducting random isogeny walks or while reconstructing such walks from their representative endomorphism-ring ideals.

In a "hybrid" approach inspired by the work of [De Feo--Jao--Plût](https://eprint.iacr.org/2011/506.pdf), I pre-generate torsion bases for each of the prime-power factors which appear in the random-walk degree. Then, during random walking, only random combinations of these fixed torsion bases must be generated. In particular, this pre-generation approach relegates the factorization of division polynomials, which is expensive, to a pre-processing step which need only be conducted once. Its results can be serialized to text, and then re-imported, for the fast reconstruction of a ready GPS signer--verifier object.

Interestingly, the factorization of division polynomials, whether during signing or preprocessing, could be avoided using Elkies--Müller-type procedures; see issue [#1](https://github.com/benediamond/GPSPostQuantum/issues/1) for discussion on this.

### Performance and Parallelization

I have generated a GPS object for a "toy-sized" prime of 16 bits (resulting in 4 bits of post-quantum security), and dumped the resulting serialization to `serializations/l = 4, p = 67967.txt`.

Again inspired by De Feo--Jao--Plût, I chose `p = 67967` because of the low multiplicative order of `p` modulo the prime powers appearing in the degree of its resulting isogeny walk. The idea is that poor performance during key-generation and signing comes primarily from the high degrees of the extension fields over which certain particular prime powers' torsion generators reside. In particular, among those primes `p > 2^16`, 67967 minimizes the maximum of ord(p, l_i^{e_i}) as l_i^{e_i} ranges throughout the minimal set of prime powers for which adequate mixing in `p`'s isogeny graph is achieved (see GPS, Lemma 1). (More precisely, we control the order of `p` modulo each {1, ..., l_i^{e_i} - 1} / (x ~ -x), where the former is viewed as an automorphism, or rather bijection, of the latter via multiplication. This order constitutes an upper bound on the degree of any particular irreducible factor of the l_i^{e_i}th division polynomial.)

Even this pre-generation step took some time---about a day's worth of work on a single thread of a MacBook Pro. However, there are ways that the construction of torsion bases could become vastly faster; see again issue [#1](https://github.com/benediamond/GPSPostQuantum/issues/1).

Beyond this theoretically grounded improvement, both preprocessing _and_ signing would benefit vastly from parallelization. See [#4](https://github.com/benediamond/GPSPostQuantum/issues/4) for more discussion on this. Put simply, parallelization would impose virtually no overhead, in the sense that with multiple cores would simply divide the total time correspondingly.

In particular, using even using the small `p = 67967`, signing takes an uncomfortable 7 minutes or so. This time could be divided, however, by however many parallel threads one had access to.

Verifying takes about 5 seconds, and uses the [modular polynomials database](https://math.mit.edu/~drew/ClassicalModPolys.html) of Andrew Sutherland, whom I thank. The relevant files (i.e., for each l_i^{e_i}) must placed in a top-level directory `/modular/`.

### Differences from Galbraith--Petit--Silva: Detail

I now describe the differences from the paper of GPS in more detail.

* As described above, I move torsion-basis-generation to a preprocessing step. During walking, for each l_i^{e_i}, only the coefficients of each Q_i with respect to the pre-computed l_i^{e_i}-torsion basis must be computed.
* As a consequence of this, it is necessary, for the success of Algorithm 2, that the powersmooth norm S of the endormorphism ring ideal generated by Algorithm 1 be known in advance. Resultingly, it not possible to dynamically adjust the powersmooth numbers S_1 and S_2 as suggested in GPS, Algorithm 1. I therefore require that S_1 * S_2 equal the powersmooth norm S_1 * S_2 originally chosen. On the other hand, it is _not_ necessary, as appears to be implied by Algorithm 3, that these numbers _individually_ (at least at first) agree with their equivalents specified in section 4.5, but only that their product does. I therefore choose, in order to ensure that the right-hand sides of 11 and 18 be large enough, an "imbalanced" approach where S_2 is much larger than S_1.
* As another consequence, line 14 of Algorithm 1 can't go through as written. Instead, I keep regenerating _beta_1_ until the Legendre condition of line 14 is true immediately (that is, with r = 1).
* The "linear algebra modulo _N_" of line 13, described further in [Kohel, Lauter, Petit, and Tignol](https://eprint.iacr.org/2014/505.pdf), section 4.3, requires an isomorphism O/NO --> M_2(Z / NZ). This isomorphism is easiest to compute when N is expressible as a sum of two squares (see Keith Conrad's [explainer](https://kconrad.math.uconn.edu/blurbs/ringtheory/quaternionalg.pdf) on quaterion algebras, Theorem 4.16). I thus enforce in Algorithm 1, line 6 that N = 1 (mod 4) (see his Theorem 4.14 for why).

There are more changes that I can't recall; I will try to add these as time goes on.

## Building and Usage Instructions

First, build and install the `f_q_support` branch of [my fork of LiDIA](https://github.com/benediamond/LiDIA/tree/f_q_support). Also install [crypto++](https://www.cryptopp.com/).

Once you've done this, GPS can be built using something like:
```bash
g++ main.cc walker.cc gps.cc extension.cc -isystem/usr/local/include -L/usr/local/lib -o main -lLiDIA -lgmp -lm -lcryptopp -std="c++11" -O2
```
An example of usage is given in the file `main.cc`, which imports a GPS object from a file, generates a keypair, and signs and verifies a message. Here is an example output:

```bash
enter random seed...12341234
embedding: 
(1 58403 )
(0 67966 ) mod 67967

restriction: 
(1 58403 )
(0 67966 ) mod 67967

l^e = 81, stepped: (39593 * x+ 56176)
l^e = 49, stepped: (60850 * x+ 46134)
l^e = 13, stepped: (35427 * x+ 63117)
l^e = 19, stepped: (53746 * x+ 48188)
l^e = 29, stepped: (20620 * x+ 14414)
l^e = 37, stepped: (17302 * x+ 11411)
l^e = 43, stepped: (54248 * x+ 6304)
l^e = 53, stepped: (53883 * x+ 15241)
l^e = 61, stepped: (136 * x+ 14918)
l^e = 71, stepped: (7154 * x+ 64094)
l^e = 79, stepped: (3631 * x+ 22723)

<<TRUNCATED>>

4F7C (37401 * x+ 48086) (10200 * x+ 39385) (12746 * x+ 1456) (19850 * x+ 54542) (53413 * x+ 37956) (31969 * x+ 65012) (28388 * x+ 55818) (10261 * x+ 38610) (52404 * x+ 63450) (9425 * x+ 47086) (1741 * x+ 882) (28197 * x+ 59010) (11519 * x+ 23190) (235 * x+ 3575) (37708 * x+ 15417) (25427 * x+ 52004) (18203 * x+ 10212) (66508 * x+ 2557) (33439 * x+ 52630) (67783 * x+ 28919) (25494 * x+ 39200) (20881 * x+ 56191) (33599 * x+ 35484) (50909 * x+ 27059) (23463 * x+ 52673) (6854 * x+ 48020) (18273) (53733 * x+ 46350) (7177 * x+ 55310) (9158 * x+ 49456) (58796 * x+ 30745) (37526 * x+ 47893) (35384 * x+ 44448) (31321 * x+ 46313) (40955 * x+ 41253) (40633 * x+ 34081) (23962 * x+ 44590) (35704 * x+ 53807) (52516 * x+ 12547) (30438 * x+ 41806) (24754 * x+ 21086) (14628 * x+ 53364) (37913 * x+ 33027) (22335) (52955 * x+ 24708) (9044 * x+ 11695) (19882 * x+ 43751) (24530 * x+ 58735) (16727) (39171 * x+ 48475) (29471 * x+ 44844) (30575 * x+ 25091) (31797 * x+ 1117) (67913 * x+ 45148) (39860 * x+ 20871) (52073 * x+ 15655) (56332 * x+ 28977) (7076 * x+ 8220) (26953 * x+ 65098) (16429 * x+ 33368) (39543 * x+ 30121) (6098 * x+ 28477) (27899 * x+ 33164) (20760 * x+ 34700) (65721 * x+ 63330) (20295 * x+ 49604) (43243 * x+ 34129) (66517 * x+ 31617) (2352 * x+ 4105) (30195) (60298 * x+ 8143) (64703 * x+ 29457) (15169 * x+ 53027) (65128 * x+ 3357) (47070 * x+ 41261) (25047 * x+ 58874) (21010 * x+ 22158) (38900 * x+ 971) (37256 * x+ 14700) (40214 * x+ 16204) (7570 * x+ 34889) (35624 * x+ 33327) (14605 * x+ 67427) (29766 * x+ 38640) (10400 * x+ 44168) (63369 * x+ 4251) (50995 * x+ 43400) (153 * x+ 343) (27877 * x+ 25565) (13256 * x+ 6523) (54388 * x+ 29810) (593 * x+ 32915) (50910 * x+ 12502) (1789 * x+ 17629) (29615 * x+ 27952) (39563 * x+ 22839) (62155 * x+ 46742) (53915 * x+ 22290) (65936 * x+ 31551) (33739 * x+ 12386) (44832 * x+ 26587) (67831 * x+ 5587) (22584 * x+ 40557) (16984 * x+ 52313) (3514 * x+ 8315) (53511 * x+ 60010) (45944 * x+ 24821) (65756 * x+ 54141) (34832 * x+ 42454) (22299 * x+ 62272) (31367 * x+ 20716) (66174 * x+ 50374) 8849660611FAF30DAEE49FBE52DA631B7B06F20CBA0C1821A53E913FCC36A562CE2935E49F14C3085FAFC1A0B5A88B 1216FC9EFFC7660DD11E1107DCB1412C49E4A52E109A5A5A30FF4F14C3CB08F8AAC72A22B0C39714ED5360C2840699 BF4CBDDCE33E9CE0B5498849A8625EC9E2ED03B2C925E94E6366 FA23EFC3C4C44530C259C77885938849A551545633E3CF829FFB9DBCFAAE3B1F23943D10DCD48C4AFE9DA6F5C244E6 A7D600B49E4BA11EE9A6F055065AE660535939891752B1B2AB54 4DD2D4FBD50BBC9FB010FE5345897A5F91100F7B557249739416 A44B605B32516B2D7DD974DF57F3D3E393310254D713B629BE25 DD1EDC1748080712AC94A8F412A9224D6EA70E12E94DBB3BF1C8 6303A19E0ED7E6F249EB27D9DF03ECF223F0C3A75505A0D14895 2C9347AECD9D26B9622E50D5D412A2F1AACB7993EB90F15DB1A7 4BCD69DDE68866F03EC6965ED5E04C45618AF3896C75FBCFE87B 80F5F4122C5778F5CBF3A095793671EB22AA4B3E9E449F23FD2E8F58214E0FE7B55D90A4755EC3DB9344627F1274D3 
1
```

## Contributing

I would welcome contributions by anyone interested. Feel free to raise a pull request or leave comments. See also the [issues](https://github.com/benediamond/GPSPostQuantum/issues/). Thanks for your interest!
